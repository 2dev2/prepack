<!DOCTYPE html>
<html>
  <head>
    <title>Prepack &middot; Partial evaluator for JavaScript</title>
    <link rel="stylesheet" href="css/style.css">
  </head>
  <body>
    <header>
      <div class="content-container">
        <h1>Prepack</h1>

        <nav>
          <ul>
            <li><a class="active" href="./">About</a></li>
            <li><a href="repl.html">REPL</a></li>
          </ul>

          <ul class="right">
            <li><a href="https://github.com/facebook/prepack">GitHub</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <div class="content content-container">
      <h2>What is Prepack?</h2>
      <p>
        Prepack is a partial evaluator for JavaScript. It rewrites a JavaScript bundle, optimizing the initialization code.
      </p>
      <h2>How does it work?</h2>
      <p>
        Prepack fully evaluates the initialization code in a JavaScript bundle and persists the resulting initialized heap as straightforward JavaScript code that efficiently rebuilds the heap without creating any temporary objects or values. The code for any functions that are referenced by the initialization code and are reachable from the initialized heap is retained in the residual program. Prepack may speculatively partially evaluate such residual functions, in particular residual module factory functions.
      </p>
      <p>
        <a href="repl.html">Try it yourself!</a>
      </p>
      <h2>The Environment matters!</h2>
      <p>
        At the core of Prepack is an almost ECMAScript 5 compatible interpreter. 
        Out of the box, Prepack does not fully model a browser or node.js environment: Prepack has no built-in knowledge of <code>document</code> or <code>window</code>. In fact, when prepacking code which references such properties, they will evaluate to <code>undefined</code>. You would have to insert a model of the relevant functionality at the beginning of the code you want to prepack.
      </p>
      <p>The following helper functions aid in writing models.
      <pre>
        // Assume that a certain property has a simple known value.
        __assumeDataProperty(global, "obscure", undefined);
        // Assume that a certain property has a simple unknown value.
        __assumeDataProperty(global, "notSoObscure", __abstract());
        // Assume that a richly structured value exists
        __assumeDataProperty(global, "rich", __abstract({
          x: __abstract("number"),
          y: __abstract("boolean"),
          z: __abstract("string"),
          nested: __abstract({
            x: __abstract()
          })
        }));
        // Forbid any accesses to an object except at known positions
        __makePartial(global);
        // At this point, accessing global.obscure, global.notSoObscure, global.rich.nested.x is okay, 
        // but accessing global.unknown or global.rich.unknown would cause an introspection error.
      </pre>
      <h2>Examples!</h2>
      <h3>Hello World</h3>
      <pre>
      (function () {
        function hello() { return 'hello'; }
        function world() { return 'world'; }
        global.s = hello() + ' ' + world();
      })();
      </pre>
      becomes
      <pre>
      (function () {
        s = "hello world";
      })();
      </pre>
      <h3>Fibonacci</h3>
      <pre>
      (function () {
        function fibonacci(x) {
          return x <= 1 ? x : fibonacci(x - 1) + fibonacci(x - 2);
        }
        global.x = fibonacci(23);
      })();
      </pre>
      becomes
      <pre>
      (function () {
        x = 28657;
      })();
      </pre>
      <h3>Module Initialization</h3>
      <pre>
      (function () {
        let moduleTable = {};
        function define(id, f) { moduleTable[id] = f; }
        function require(id) {
          let x = moduleTable[id];
          return x instanceof Function ? (moduleTable[id] = x()) : x;
        }
        global.require = require;
        define("one", function() { return 1; }, "one");
        define("two", function() { return require("one") + require("one"); });
        define("three", function() { return require("two") + require("one"); });
        define("four", function() { return require("three") + require("one"); });
      })();
      three = require("three");
      </pre>
      becomes
      <pre>
      (function () {
        function _2() {
          return 3 + 1;
        }

        var _1 = {
          one: 1,
          two: 2,
          three: 3,
          four: _2
        };

        function _0(id) {
          let x = _1[id];
          return x instanceof Function ? _1[id] = x() : x;
        }

        require = _0;
        three = 3;
      })();
      </pre>
      Note how most computations have been pre-initialized. However, the function that computes four (_2) remains in the residual program.
      <h3>Environment Interactions and Branching</h3>
      <pre>
      (function(){
        function fib(x) { return x <= 1 ? x : fib(x - 1) + fib(x - 2); }
        let x = Date.now();
        if (x === 0) x = fib(10);
        global.result = x;
      })();
      </pre>
      becomes
      <pre>
      (function () {
        var _0 = Date.now();
        if (typeof _0 !== "number") {
          throw new Error("Prepack model invariant violation");
        }
        result = _0 === 0 ? 55 : _0;
      })();
      </pre>
    </div>
  </body>
</html>
